{
  
    
        "post0": {
            "title": "前缀和",
            "content": "1. 前缀和 . 题目连接 . . 示例1 . 输入： . 3 2 1 2 4 1 2 2 3 . 输出： . 3 6 . Solution . import java.util.Scanner; public class PrefixSum { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int q = in.nextInt(); int l, r; long[] f = new long[n+1]; for (int i = 1; i &lt;=n; i++) { f[i] = in.nextInt() + f[i-1]; } for (int i = 0; i &lt; q; i++) { l = in.nextInt(); r = in.nextInt(); System.out.println(f[r] - f[l-1]); } } } . 2. 二维前缀和 . 题目连接 . 示例1 . 输入： . 3 4 3 1 2 3 4 3 2 1 0 1 5 7 8 1 1 2 2 1 1 3 3 1 2 3 4 . 输出： . 8 25 32 . Solution . import java.util.Scanner; public class PrefixSum2D { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); int q = in.nextInt(); long[][] f = new long[n + 1][m + 1]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { f[i][j] = in.nextInt() + f[i][j - 1] + f[i - 1][j] - f[i - 1][j - 1]; } } int x1, x2, y1, y2; for (int i = 0; i &lt; q; i++) { x1 = in.nextInt(); y1 = in.nextInt(); x2 = in.nextInt(); y2 = in.nextInt(); System.out.println(f[x2][y2] - f[x2][y1 - 1] - f[x1 - 1][y2] + f[x1 - 1][y1 - 1]); } } } . 3. abb . 题目连接 . 示例1 . 输入： . 6 abcbcc . 输出： . 8 . 说明： . 共有1个abb，3个acc，4个bcc . 示例2 . 输入： . 4 abbb . 输出： . 3 . Solution . 只关注当前字符以及之后的字符。 . import java.util.HashMap; import java.util.Map; import java.util.Scanner; public class ABB { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); in.nextLine(); // 跳过n后面的换行符 long ans = 0; char[] s = in.nextLine().toCharArray(); Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;(); for (char c : s) { m.put(c, m.getOrDefault(c, 0) + 1); } for (char c : s) { m.put(c, m.get(c) - 1); for (char key : m.keySet()) { if (c != key) { ans += ((long) m.get(key) * (m.get(key) - 1)) / 2; } } } System.out.println(ans); } } .",
            "url": "https://lxfz.github.io/blog/algorithm/2022/05/07/12-%E5%89%8D%E7%BC%80%E5%92%8C-DP.html",
            "relUrl": "/algorithm/2022/05/07/12-%E5%89%8D%E7%BC%80%E5%92%8C-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "11 记忆化搜索",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/11-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.html",
            "relUrl": "/2022/05/07/11-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "10 博弈型 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/10-%E5%8D%9A%E5%BC%88%E5%9E%8B-DP.html",
            "relUrl": "/2022/05/07/10-%E5%8D%9A%E5%BC%88%E5%9E%8B-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "09 概率型 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/09-%E6%A6%82%E7%8E%87%E5%9E%8B-DP.html",
            "relUrl": "/2022/05/07/09-%E6%A6%82%E7%8E%87%E5%9E%8B-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "08 递推型 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/08-%E9%80%92%E6%8E%A8%E5%9E%8B-DP.html",
            "relUrl": "/2022/05/07/08-%E9%80%92%E6%8E%A8%E5%9E%8B-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "07 计数型 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/07-%E8%AE%A1%E6%95%B0%E5%9E%8B-DP.html",
            "relUrl": "/2022/05/07/07-%E8%AE%A1%E6%95%B0%E5%9E%8B-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "06 数位 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/06-%E6%95%B0%E4%BD%8D-DP.html",
            "relUrl": "/2022/05/07/06-%E6%95%B0%E4%BD%8D-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "05 状态压缩 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/05-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP.html",
            "relUrl": "/2022/05/07/05-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "04 树形 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/04-%E6%A0%91%E5%BD%A2-DP.html",
            "relUrl": "/2022/05/07/04-%E6%A0%91%E5%BD%A2-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "03 背包 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/03-%E8%83%8C%E5%8C%85-DP.html",
            "relUrl": "/2022/05/07/03-%E8%83%8C%E5%8C%85-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "02 区间 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/02-%E5%8C%BA%E9%97%B4-DP.html",
            "relUrl": "/2022/05/07/02-%E5%8C%BA%E9%97%B4-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "01 线性 dp",
            "content": "",
            "url": "https://lxfz.github.io/blog/2022/05/07/01-%E7%BA%BF%E6%80%A7-DP.html",
            "relUrl": "/2022/05/07/01-%E7%BA%BF%E6%80%A7-DP.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "Java 动态代理",
            "content": "Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 . 实现动态代理需要的两个类： . InvocationHandler | Proxy | . package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; interface Hello { void morning(String name); } public class DynamicProxy { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if (method.getName().equals(&quot;morning&quot;)) { System.out.println(&quot;Good morning: &quot; + args[0]); } return null; } }; // Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； // invocationHandler 代理被调用的接口方法 Hello hello = (Hello) Proxy.newProxyInstance( Hello.class.getClassLoader(), // 传入ClassLoader new Class[] { Hello.class }, // 传入要实现的接口 handler // 传入处理调用方法的InvocationHandler ); hello.morning(&quot;Bob&quot;); } } . 把上面的动态代理改写为静态实现类大概长这样： . public class HelloDynamicProxy implements Hello { InvocationHandler handler; public HelloDynamicProxy(InvocationHandler handler) { this.handler = handler; } public void morning(String name) { handler.invoke( this, Hello.class.getMethod(&quot;morning&quot;, String.class), new Object[] { name }); } } . References . 参考 01 . | 参考 02 . | .",
            "url": "https://lxfz.github.io/blog/java/2022/04/20/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",
            "relUrl": "/java/2022/04/20/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html",
            "date": " • Apr 20, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "Java反射(Reflection)",
            "content": "Java的反射是指程序在运行期可以拿到一个对象的所有信息。反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。实现Java一切皆对象，类也是对象。 . 一、Class类 . public final class Class { private Class() {} } . Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 . 一个Class实例包含了某个类class的所有完整信息，通过Class实例获取class信息的方法称为反射（Reflection）： . ┌───────────────────────────┐ │ Class Instance │──────&gt; String ├───────────────────────────┤ │name = &quot;java.lang.String&quot; │ ├───────────────────────────┤ │package = &quot;java.lang&quot; │ ├───────────────────────────┤ │super = &quot;java.lang.Object&quot; │ ├───────────────────────────┤ │interface = CharSequence...│ ├───────────────────────────┤ │field = value[],hash,... │ ├───────────────────────────┤ │method = indexOf()... │ └───────────────────────────┘ . 如何获取一个class的Class实例？有三个方法： . 方法一：直接通过一个class的静态变量class获取： . Class cls = String.class; . 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： . String s = &quot;Hello&quot;; Class cls = s.getClass(); . 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： . Class cls = Class.forName(&quot;java.lang.String&quot;); . 从Class实例获取获取的基本信息 . public class Main { public static void main(String[] args) { printClassInfo(&quot;&quot;.getClass()); printClassInfo(Runnable.class); printClassInfo(java.time.Month.class); printClassInfo(String[].class); printClassInfo(int.class); } static void printClassInfo(Class cls) { System.out.println(&quot;Class name: &quot; + cls.getName()); System.out.println(&quot;Simple name: &quot; + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(&quot;Package name: &quot; + cls.getPackage().getName()); } System.out.println(&quot;is interface: &quot; + cls.isInterface()); System.out.println(&quot;is enum: &quot; + cls.isEnum()); System.out.println(&quot;is array: &quot; + cls.isArray()); System.out.println(&quot;is primitive: &quot; + cls.isPrimitive()); } } . 动态加载: JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。 . 二、访问字段 . Class类提供了以下几个方法来获取字段： . Field getField(name)：根据字段名获取某个public的field（包括父类） | Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） | Field[] getFields()：获取所有public的field（包括父类） | Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） | . 参考 . 三、调用方法 . Class类提供了以下几个方法来获取Method： . Method getMethod(name, Class...)：获取某个public的Method（包括父类） | Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） | Method[] getMethods()：获取所有public的Method（包括父类） | Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） | . 参考 . 四、调用构造方法 . Person p = Person.class.newInstance(); . 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 . 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。通过Class实例获取Constructor的方法如下： . getConstructor(Class...)：获取某个public的Constructor； | getDeclaredConstructor(Class...)：获取某个Constructor； | getConstructors()：获取所有public的Constructor； | getDeclaredConstructors()：获取所有Constructor。 | . 参考 . 五、获取继承关系 . 通过Class对象可以获取继承关系： . Class getSuperclass()：获取父类类型； | Class[] getInterfaces()：获取当前类实现的所有接口。 | . 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现 . 参考 .",
            "url": "https://lxfz.github.io/blog/java/2022/04/19/Java%E5%8F%8D%E5%B0%84.html",
            "relUrl": "/java/2022/04/19/Java%E5%8F%8D%E5%B0%84.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "IoC基础理解",
            "content": "一、什么是IoC . public class BookService { private HikariConfig config = new HikariConfig(); private DataSource dataSource = new HikariDataSource(config); public Book getBook(long bookId) { try (Connection conn = dataSource.getConnection()) { ... return book; } } } . 从这个类中可以看出，在创建BookService的过程中，需要创建HikariConfig和DataSource组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。 . 如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。 . 因此，核心问题是： . 谁负责创建组件？ | 谁负责根据依赖关系组装组件？ | 销毁时，如何按依赖顺序正确销毁？ | 解决这一问题的核心方案就是IoC。 . 在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。 . 解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。 . 二、注入方式 . 1. set 注入 . public class BookService { private DataSource dataSource; public void setDataSource(DataSource dataSource) { this.dataSource = dataSource; } } . 2. 构造方法注入 . public class BookService { private DataSource dataSource; public BookService(DataSource dataSource) { this.dataSource = dataSource; } } . Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。 .",
            "url": "https://lxfz.github.io/blog/spring/2022/04/19/IoC%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3.html",
            "relUrl": "/spring/2022/04/19/IoC%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "Pattern 17: Kth Smallest Number",
            "content": "Problem Statement: . Given an unsorted array of numbers, find Kth smallest number in it. . Please note that it is the Kth smallest number in the sorted order, not the Kth distinct element. . Example 1: . Input: [1, 5, 12, 2, 11, 5], K = 3 . Output: 5 . Explanation: The 3rd smallest number is &#39;5&#39;, as the first two smaller numbers are [1, 2]. . Example 2: . Input: [1, 5, 12, 2, 11, 5], K = 4 . Output: 5 . Explanation: The 4th smallest number is &#39;5&#39;, as the first three smaller numbers are [1, 2, 5]. . Example 3: . Input: [5, 12, 11, -1, 12], K = 3 . Output: 11 . Explanation: The 3rd smallest number is &#39;11&#39;, as the first two small numbers are [5, -1]. . 1. Sort . def find_Kth_smallest_number(nums, k): return sorted(nums)[k-1] def main(): print(&quot;Kth smallest number is: &quot; + str(find_Kth_smallest_number([1, 5, 12, 2, 11, 5], 3))) # since there are two 5s in the input array, our 3rd and 4th smallest numbers should be a &#39;5&#39; print(&quot;Kth smallest number is: &quot; + str(find_Kth_smallest_number([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(find_Kth_smallest_number([5, 12, 11, -1, 12], 3))) main() . Kth smallest number is: 5 Kth smallest number is: 5 Kth smallest number is: 11 . Time &amp; Space Complexity: . Sorting will take O(NlogN) and if we are not using an in-place sorting algorithm, we will need O(N) space. . 2. Max Heap . 在大顶堆中维持K个最小的元素。放入、取出时都加负号即可实现大顶堆。 . from heapq import * def find_Kth_smallest_number(nums, k): maxHeap = [] # put first k numbers in the max heap for i in range(k): heappush(maxHeap, -nums[i]) # go through the remaining numbers of the array, if the number from the array is smaller than the # top(biggest) number of the heap, remove the top number from heap and add the number from array for i in range(k, len(nums)): if nums[i] &lt; -maxHeap[0]: heappop(maxHeap) heappush(maxHeap, -nums[i]) # the root of the heap has the Kth smallest number return -maxHeap[0] . def main(): print(&quot;Kth smallest number is: &quot; + str(find_Kth_smallest_number([1, 5, 12, 2, 11, 5], 3))) # since there are two 5s in the input array, our 3rd and 4th smallest numbers should be a &#39;5&#39; print(&quot;Kth smallest number is: &quot; + str(find_Kth_smallest_number([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(find_Kth_smallest_number([5, 12, 11, -1, 12], 3))) main() . Kth smallest number is: 5 Kth smallest number is: 5 Kth smallest number is: 11 . Time &amp; Space Complexity: . The time complexity of the above algorithm is O(KlogK + (N-K)logK) which is asymptotically equal to O(N*logK). . The space complexity will be O(K) because we need to store ‘K’ smallest numbers in the heap. .",
            "url": "https://lxfz.github.io/blog/algorithm%20pattern/2022/04/17/Pattern-17.html",
            "relUrl": "/algorithm%20pattern/2022/04/17/Pattern-17.html",
            "date": " • Apr 17, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "Pattern 7: Tree Breadth First Search",
            "content": "1. Binary Tree Level Order Traversal (easy) . Problem Statement: . Given a binary tree, populate an array to represent its level-by-level traversal. . You should populate the values of all nodes of each level from left to right in separate sub-arrays. . Solution: . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def level_traverse(root): result = [] if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) currentLevel = [] for _ in range(levelSize): currentNode = queue.popleft() # add the node to the current level currentLevel.append(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) result.append(currentLevel) return result . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Level order traversal: &quot; + str(level_traverse(root))) . main() . Level order traversal: [[12], [7, 1], [9, 10, 5]] . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. . We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 2. Reverse Level Order Traversal (easy) . Problem Statement: . Given a binary tree, populate an array to represent its level-by-level traversal in reverse order, i.e., the lowest level comes first. . You should populate the values of all nodes in each level from left to right in separate sub-arrays. . Solution . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def reverse_level_traverse(root): result = deque() if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) currentLevel = [] for _ in range(levelSize): currentNode = queue.popleft() # add the node to the current level currentLevel.append(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) result.appendleft(currentLevel) return result . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Reverse level order traversal: &quot; + str(reverse_level_traverse(root))) main() . Reverse level order traversal: deque([[9, 10, 5], [7, 1], [12]]) . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. . We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 3. Zigzag Traversal (medium) . Problem Statement: . Given a binary tree, populate an array to represent its zigzag level order traversal. . You should populate the values of all nodes of the first level from left to right, then right to left for the next level and keep alternating in the same manner for the following levels. . Solution . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def zigzag_traverse(root): result = [] if root is None: return result queue = deque() queue.append(root) leftToRight = True while queue: levelSize = len(queue) currentLevel = deque() for _ in range(levelSize): currentNode = queue.popleft() # add the node to the current level based on the traverse direction if leftToRight: currentLevel.append(currentNode.val) else: currentLevel.appendleft(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) result.append(list(currentLevel)) # reverse the traversal direction leftToRight = not leftToRight return result . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) root.right.left.left = TreeNode(20) root.right.left.right = TreeNode(17) print(&quot;Zigzag traversal: &quot; + str(zigzag_traverse(root))) main() . Zigzag traversal: [[12], [1, 7], [9, 10, 5], [17, 20]] . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. . We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 4. Level Averages in a Binary Tree (easy) . Problem Statement: . Given a binary tree, populate an array to represent the averages of all of its levels. . Solution . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def find_level_averages(root): result = [] if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) levelSum = 0.0 for _ in range(levelSize): currentNode = queue.popleft() # add the node&#39;s value to the running sum levelSum += currentNode.val # insert the children of current node to the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) # append the current level&#39;s average to the result array result.append(levelSum / levelSize) return result . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.left.right = TreeNode(2) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Level averages are: &quot; + str(find_level_averages(root))) main() . Level averages are: [12.0, 4.0, 6.5] . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N)O which is required for the queue. . Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 5. Minimum Depth of a Binary Tree (easy) . Problem Statement: . Find the minimum depth of a binary tree. . The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node. . Solution . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def find_minimum_depth(root): if root is None: return 0 queue = deque() queue.append(root) minimumTreeDepth = 0 while queue: minimumTreeDepth += 1 levelSize = len(queue) for _ in range(levelSize): currentNode = queue.popleft() # check if this is a leaf node if not currentNode.left and not currentNode.right: return minimumTreeDepth # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Tree Minimum Depth: &quot; + str(find_minimum_depth(root))) root.left.left = TreeNode(9) root.right.left.left = TreeNode(11) print(&quot;Tree Minimum Depth: &quot; + str(find_minimum_depth(root))) main() . Tree Minimum Depth: 2 Tree Minimum Depth: 3 . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N)O which is required for the queue. . Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . Similar Problems . Problem 1: Given a binary tree, find its maximum depth (or height). . 6. Level Order Successor (easy) . Problem Statement: . Given a binary tree and a node, find the level order successor of the given node in the tree. . The level order successor is the node that appears right after the given node in the level order traversal. . Solution: . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def find_successor(root, key): if root is None: return None queue = deque() queue.append(root) while queue: currentNode = queue.popleft() # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) # break if we have found the key if currentNode.val == key: break return queue[0] if queue else None . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) result = find_successor(root, 12) if result: print(result.val) result = find_successor(root, 9) if result: print(result.val) main() . 7 10 . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N) which is required for the queue. . Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 7. Connect Level Order Siblings (medium) . Problem Statement: . Given a binary tree, connect each node with its level order successor. . The last node of each level should point to a null node. . Solution . from collections import deque class TreeNode: def __init__(self, val): self.val = val self.left, self.right, self.next = None, None, None # level order traversal using &#39;next&#39; pointer def print_level_order(self): nextLevelRoot = self while nextLevelRoot: current = nextLevelRoot nextLevelRoot = None while current: print(str(current.val) + &quot; &quot;, end=&#39;&#39;) if not nextLevelRoot: if current.left: nextLevelRoot = current.left elif current.right: nextLevelRoot = current.right current = current.next print() . def connect_level_order_siblings(root): if root is None: return queue = deque() queue.append(root) while queue: previousNode = None levelSize = len(queue) # connect all nodes of this level for _ in range(levelSize): currentNode = queue.popleft() if previousNode: previousNode.next = currentNode previousNode = currentNode # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) connect_level_order_siblings(root) print(&quot;Level order traversal using &#39;next&#39; pointer: &quot;) root.print_level_order() main() . Level order traversal using &#39;next&#39; pointer: 12 7 1 9 10 5 . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N), which is required for the queue. . Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 8. Problem Challenge 1 - Connect All Level Order Siblings (medium) . Problem Statement . Connect All Level Order Siblings (medium) Given a binary tree, connect each node with its level order successor. . The last node of each level should point to the first node of the next level. . Solution . from collections import deque class TreeNode: def __init__(self, val): self.val = val self.left, self.right, self.next = None, None, None # tree traversal using &#39;next&#39; pointer def print_tree(self): print(&quot;Traversal using &#39;next&#39; pointer: &quot;, end=&#39;&#39;) current = self while current: print(str(current.val) + &quot; &quot;, end=&#39;&#39;) current = current.next . def connect_all_siblings(root): if root is None: return queue = deque() queue.append(root) currentNode, previousNode = None, None while queue: currentNode = queue.popleft() if previousNode: previousNode.next = currentNode previousNode = currentNode # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) connect_all_siblings(root) root.print_tree() main() . Traversal using &#39;next&#39; pointer: 12 7 1 9 10 5 . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N) which is required for the queue. . Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. . 9. Problem Challenge 2 - Right View of a Binary Tree (easy) . Problem Statement: . Given a binary tree, return an array containing nodes in its right view. . The right view of a binary tree is the set of nodes visible when the tree is seen from the right side. . Solution . from collections import deque . class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left, self.right = left, right . def tree_right_view(root): result = [] if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) for i in range(0, levelSize): currentNode = queue.popleft() # if it is the last node of this level, add it to the result if i == levelSize - 1: result.append(currentNode) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) return result . def main(): root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) root.left.left.left = TreeNode(3) result = tree_right_view(root) print(&quot;Tree right view: &quot;) for node in result: print(str(node.val) + &quot; &quot;, end=&#39;&#39;) main() . Tree right view: 12 1 5 3 . Time complexity: . The time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. . This is due to the fact that we traverse each node once. . Space complexity: . The space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. . We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. .",
            "url": "https://lxfz.github.io/blog/algorithm%20pattern/2022/04/17/Pattern-07.html",
            "relUrl": "/algorithm%20pattern/2022/04/17/Pattern-07.html",
            "date": " • Apr 17, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "Design Pattern--行为型--责任链模式",
            "content": "责任链模式(Chain of Responsibility)是一种处理请求的模式，多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 . . 在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为： . Manager：只能审核1000元以下的报销； | Director：只能审核10000元以下的报销； | CEO：可以审核任意额度。 | . 用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。 . public class Request { private String name; private BigDecimal amount; public Request(String name, BigDecimal amount) { this.name = name; this.amount = amount; } public String getName() { return name; } public BigDecimal getAmount() { return amount; } } . public interface Handler { // 返回Boolean.TRUE = 成功 // 返回Boolean.FALSE = 拒绝 // 返回null = 交下一个处理 Boolean process(Request request); } public class ManagerHandler implements Handler { public Boolean process(Request request) { // 如果超过1000元，处理不了，交下一个处理: if (request.getAmount().compareTo(BigDecimal.valueOf(1000)) &gt; 0) { return null; } // 对Bob有偏见, 拒绝Bob: return !request.getName().equalsIgnoreCase(&quot;bob&quot;); } } public class DirectorHandler implements Handler{ public Boolean process(Request request) { // 如果超过10000元，处理不了，交下一个处理: if (request.getAmount().compareTo(BigDecimal.valueOf(10000)) &gt; 0) { return null; } return Boolean.TRUE; } } public class CEOHandler implements Handler{ public Boolean process(Request request) { // CEO 可以审核任意额度。 return Boolean.TRUE; } } . public class HandlerChain { // 持有所有Handler: private List&lt;Handler&gt; handlers = new ArrayList&lt;&gt;(); public void addHandler(Handler handler) { this.handlers.add(handler); } public boolean process(Request request) { // 依次调用每个Handler: for (Handler handler : handlers) { Boolean r = handler.process(request); if (r != null) { // 如果返回TRUE或FALSE，处理结束: System.out.println(request + &quot; &quot; + (r ? &quot;Approved by &quot; : &quot;Denied by &quot;) + handler.getClass().getSimpleName()); return r; } } throw new RuntimeException(&quot;Could not handle request: &quot; + request); } } . public class Client { public static void main(String[] args) { // 构造责任链: HandlerChain chain = new HandlerChain(); chain.addHandler(new ManagerHandler()); chain.addHandler(new DirectorHandler()); chain.addHandler(new CEOHandler()); // 处理请求: chain.process(new Request(&quot;Bob&quot;, new BigDecimal(&quot;123.45&quot;))); chain.process(new Request(&quot;Alice&quot;, new BigDecimal(&quot;1234.56&quot;))); chain.process(new Request(&quot;Bill&quot;, new BigDecimal(&quot;12345.67&quot;))); chain.process(new Request(&quot;John&quot;, new BigDecimal(&quot;123456.78&quot;))); } } . References . 参考 01 | 参考 02 | .",
            "url": "https://lxfz.github.io/blog/java/2022/04/14/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html",
            "relUrl": "/java/2022/04/14/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html",
            "date": " • Apr 14, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "Design Pattern--行为型--观察者模式",
            "content": "定义 . 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。 . 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。此种模式通常被用来实时事件处理系统。 . . Class Diagram . 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。 . 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。 . . 实现 . 天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。 . . public interface Subject { void registerObserver(Observer o); void removeObserver(Observer o); void notifyObserver(); } . public class WeatherData implements Subject { private List&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList&lt;&gt;(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); } @Override public void registerObserver(Observer o) { observers.add(o); } @Override public void removeObserver(Observer o) { int i = observers.indexOf(o); if (i &gt;= 0) { observers.remove(i); } } @Override public void notifyObserver() { for (Observer o : observers) { o.update(temperature, humidity, pressure); } } } . public interface Observer { void update(float temp, float humidity, float pressure); } . public class StatisticsDisplay implements Observer { public StatisticsDisplay(Subject weatherData) { weatherData.registerObserver(this); } @Override public void update(float temp, float humidity, float pressure) { System.out.println(&quot;StatisticsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure); } } . public class CurrentConditionsDisplay implements Observer { public CurrentConditionsDisplay(Subject weatherData) { weatherData.registerObserver(this); } @Override public void update(float temp, float humidity, float pressure) { System.out.println(&quot;CurrentConditionsDisplay.update: &quot; + temp + &quot; &quot; + humidity + &quot; &quot; + pressure); } } . public class WeatherStation { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); } } . 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能。可使用链表来管理观察者。 | 创建观察者时，需要指明其观察的主题。 | . References . 参考 01 | .",
            "url": "https://lxfz.github.io/blog/java/2022/04/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html",
            "relUrl": "/java/2022/04/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html",
            "date": " • Apr 14, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "劝学",
            "content": "劝学 荀子 〔先秦〕 . 　　君子曰：学不可以已。 . 　　青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。 . 　　故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。 . 　　吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。(君子生 通：性) . 　　南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。 . 　　物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蜹聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！ . 　　积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。(江海 一作：江河) . 　　是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，鼫鼠五技而穷。《诗》曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮！”故君子结于一也。 . 　　昔者瓠巴鼓瑟，而流鱼出听；伯牙鼓琴，而六马仰秣。故声无小而不闻，行无隐而不形 。玉在山而草木润，渊生珠而崖不枯。为善不积邪？安有不闻者乎？ . 　　学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人， 真积力久则入，学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之，人也；舍 之，禽兽也。故书者，政事之纪也；诗者，中声之所止也；礼者，法之大分，类之纲纪也。 故学至乎礼而止矣。夫是之谓道德之极。礼之敬文也，乐之中和也，诗书之博也，春秋之微 也，在天地之间者毕矣。 君子之学也，入乎耳，箸乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口；口耳之间，则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲、非也，囋、非也；君子如向矣。 . 　　学莫便乎近其人。礼乐法而不说，诗书故而不切，春秋约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。 . 　　学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺诗书而已耳。则末世穷年，不免为陋儒而已。将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以诗书为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。 . 　　问楛者，勿告也；告楛者，勿问也；说楛者，勿听也。有争气者，勿与辩也。故必由其道至，然后接之；非其道则避之。故礼恭，而后可与言道之方；辞顺，而后可与言道之理；色从而后可与言道之致。故未可与言而言，谓之傲；可与言而不言，谓之隐；不观气色而言，谓瞽。故君子不傲、不隐、不瞽，谨顺其身。诗曰：“匪交匪舒，天子所予。”此之谓也。 . 　　百发失一，不足谓善射；千里蹞步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀纣盗跖也；全之尽之，然后学者也。 . 　　君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使耳非是无欲闻也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。 .",
            "url": "https://lxfz.github.io/blog/%E6%96%87%E8%A8%80%E6%96%87/2021/11/20/%E5%8A%9D%E5%AD%A6.html",
            "relUrl": "/%E6%96%87%E8%A8%80%E6%96%87/2021/11/20/%E5%8A%9D%E5%AD%A6.html",
            "date": " • Nov 20, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "Java多线程基础",
            "content": "一. 线程简介 . 进程是程序的一次执行过程，是系统分配资源的单位 | 一个进程中至少有一个线程，也可以有多个线程 | 线程是cpu调度和执行的单位 | 注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务 器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能 执行一个代码，因为切换的很快，所以就有同时执行的错局。 | 二. 线程实现 . 线程的创建: Thread, Runnable, Callable . 1. 使用Thread创建线程 . // 继承Thread, 重写run方法，调用start开启线程 class ThreadTest extends Thread { private final int step; public ThreadTest(int step) { this.step = step; } @Override public void run() { for (int i = 0; i &lt; this.step; i++) { System.out.println(&quot;Thread : &quot; + i); } } } public class Threads { // Thread 类实现了 Runnable接口 // Callable接口是在工作三到五年后的重点 public static void main(String[] args) { ThreadTest threadTest = new ThreadTest(2000); threadTest.start(); for (int i = 0; i &lt; 200; i++) { System.out.println(&quot;Main : &quot; + i); } } } . 2. 通过Runnable创建线程 . // 通过Runnable接口的实现类启动线程 // 一个Runnable对象可以被多个线程使用 class RunnableImpl implements Runnable { private final int step; public RunnableImpl(int step) { this.step = step; } @Override public void run() { for (int i = 0; i &lt; this.step; i++) { System.out.println(&quot;Thread : &quot; + i); } } } public class Runnables { public static void main(String[] args) { new Thread(new RunnableImpl(2000)).start(); for (int i = 0; i &lt; 200; i++) { System.out.println(&quot;Main : &quot; + i); } } } . 线程安全问题 . // 购买火车票：多个线程操作同一个资源 // 问题：线程不安全 public class Ticket implements Runnable{ private int ticketNum = 10; @Override public void run() { while (true) { if (ticketNum &lt;= 0) { break; } System.out.println(Thread.currentThread().getName() + &quot;抢到了第&quot; + ticketNum-- + &quot;票&quot;); try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Ticket ticket = new Ticket(); new Thread(ticket, &quot;A&quot;).start(); new Thread(ticket, &quot;B&quot;).start(); new Thread(ticket, &quot;C&quot;).start(); } } . 3. 使用Callable创建线程 . import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; public class TestCallable implements Callable&lt;Boolean&gt; { private final int num; public TestCallable(int num) { this.num = num; } @Override public Boolean call() throws Exception { Thread.sleep(100); return this.num % 2 == 0; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable c1 = new TestCallable(3); TestCallable c2 = new TestCallable(8); TestCallable c3 = new TestCallable(332); // 1. 创建服务 ExecutorService executorService = Executors.newFixedThreadPool(3); // 2. 提交执行 Future&lt;Boolean&gt; r1 = executorService.submit(c1); Future&lt;Boolean&gt; r2 = executorService.submit(c2); Future&lt;Boolean&gt; r3 = executorService.submit(c3); // 3. 获取结果 boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); // 4. 关闭服务 executorService.shutdown(); } } . 三. 静态代理 . 1.真实对象和代理对象都要实现同一个接口Runnable . 2.真实对象可以专注于自己的业务实现：实现了Runnable接口的业务对象 . 3.代理对象可以做一些真实对象不能做的事情：Thread对象 . 四、Lambda表达式 . 接口–&gt;实现类–&gt;静态内部类–&gt;局部内部类–&gt;匿名内部类–&gt;Lambda . public class TestLambda { public static void main(String[] args) { ILike like = (A)-&gt;{ System.out.println(A + &quot;I like lambda.&quot;); }; like.lambda(&quot;A&quot;); } } // 函数式接口 interface ILike{ void lambda(String name); } . 3. 线程状态 . 4. 线程同步 . 5. 线程通信 . 6. 高级主题 .",
            "url": "https://lxfz.github.io/blog/java/2021/11/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html",
            "relUrl": "/java/2021/11/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html",
            "date": " • Nov 19, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "Python 环境配置汇总",
            "content": "1. 使用Python创建一个虚拟环境 . # create a virtual environment python3 -m venv venv # Activate the virtual environment source venv/bin/activate # Deactivate the virtual environment source venv/bin/deactivate # export pip freeze &gt; requirements.txt # upgrade pip install --upgrade pip # install pip install -r requirements.txt .",
            "url": "https://lxfz.github.io/blog/python/2021/11/17/Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html",
            "relUrl": "/python/2021/11/17/Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html",
            "date": " • Nov 17, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "Java反射与注解",
            "content": "1. 内置注解示例 . //测试内置注解 import java.util.ArrayList; import java.util.List; public class Test01 { // @Override 重写父类的方法 public String toString() { return super.toString(); } // @Deprecated 过时的方法 @Deprecated public static void stop() { System.out.println(&quot;测试 @Deprecated&quot;); } // @SuppressWarnings 抑制警告 @SuppressWarnings(&quot;all&quot;) public void sw() { List list = new ArrayList(); } public static void main(String[] args) { } } . 2. 元注解 . import java.lang.annotation.*; // 元注解 public class Test02 { @MyAnnotation public void test() {} } @Target(value = { ElementType.TYPE, // 类 ElementType.METHOD, // 方法 ElementType.FIELD, // 属性 ElementType.PARAMETER // 参数 }) // to specify how long annotations are to be retained. @Retention(value = RetentionPolicy.RUNTIME) @Inherited @Documented // 该注解将被包含在javadoc中 @interface MyAnnotation{ } .",
            "url": "https://lxfz.github.io/blog/java/2020/10/06/Java%E5%8F%8D%E5%B0%84.html",
            "relUrl": "/java/2020/10/06/Java%E5%8F%8D%E5%B0%84.html",
            "date": " • Oct 6, 2020"
        }
        
    
  
    
        ,"post23": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://lxfz.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post24": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://lxfz.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://lxfz.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://lxfz.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}